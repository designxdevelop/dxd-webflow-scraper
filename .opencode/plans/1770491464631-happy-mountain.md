# Performance Optimizations Plan

Four optimizations implemented together in a single coordinated effort. Only 3 files need changes; all others (asset-downloader, asset-cache, url-rewriter, sitemap-parser, link-extractor, worker, API, UI) remain untouched.

---

## Files to Modify

| File | Changes |
|---|---|
| `packages/scraper/src/types.ts` | Add fields to `CrawlOptions`, `CrawlResult`, `PageResult` |
| `packages/scraper/src/page-processor.ts` | Add static fast-path + `detectDynamicContent` + sitemapOnly processing |
| `packages/scraper/src/crawler.ts` | Wire AssetCache, update concurrency calc, pass new options through |
| `packages/scraper/src/index.ts` | Export `detectDynamicContent` |

---

## 1. Static Fast-Path (Auto-detect)

**Approach**: Inside `processPage`, attempt a `fetch()` first. Scan the HTML for dynamic content indicators. If none found, skip Playwright entirely and process via `rewriteHtmlDocument` (Cheerio-based, already handles all asset types including lazy media normalization).

**Detection indicators** (presence of any = dynamic, use Playwright):
- `<code-island>` elements (federated modules)
- `webpackChunk` / `rspackChunk` globals in inline scripts
- `__webpack_require__` references
- `import()` calls in inline `<script>` blocks
- `data-src` / `data-srcset` / `data-bg` attributes (need scroll triggers)

**Implementation in `page-processor.ts`**:

```typescript
// New export
export function detectDynamicContent(html: string): { isDynamic: boolean; reasons: string[] }

// New internal function
async function tryStaticPath(options: PageProcessorOptions): Promise<PageResult | null>
  // 1. fetch(url) with 10s timeout
  // 2. detectDynamicContent(html)
  // 3. If static: rewriteHtmlDocument + save to disk, return PageResult
  // 4. If dynamic or fetch fails: return null (caller falls back to Playwright)
```

The static path reuses `rewriteHtmlDocument` which already processes: stylesheets, scripts, images, media, icons, inline styles, meta images, iframes, code-islands, and lazy media normalization (`data-src` -> `src`).

**Cost of double-fetch on dynamic pages**: ~200ms wasted per dynamic page (acceptable).

---

## 2. Increase Page Parallelism

**Current**: `ceil(concurrency / 3)` browsers = ~3 pages per browser.

**Change in `crawler.ts`**:
- New env var `CRAWL_PAGES_PER_BROWSER` (default: `6`)
- Replace hardcoded `3` with configurable value
- Reduce `CRAWL_MEMORY_MB_PER_PAGE` default from `250` to `150` (Webflow pages are lighter, and static-path pages use 0 browser memory)

With concurrency=30: 5 browsers x 6 pages (was 10 browsers x 3 pages).

---

## 3. Cross-Crawl Asset Sharing

**Key finding**: `AssetCache` is fully implemented but never wired in. `AssetDownloader` receives `undefined` for its `diskCache` parameter at `crawler.ts:184`.

**Fix in `crawler.ts`**:
```typescript
import { AssetCache } from "./asset-cache.js";

// Scope cache by hostname for isolation
const cacheDir = path.join(
  process.env.LOCAL_TEMP_PATH || '/tmp',
  'dxd-asset-cache',
  new URL(options.baseUrl).hostname
);
const assetCache = new AssetCache(cacheDir);
await assetCache.init();

const assetDownloader = new AssetDownloader(resolvedOutput, assetCache, { ... });

// After crawl completes:
await assetCache.evict();
log.info(`Asset cache: ${cacheStats.hitRate} hit rate`);
```

Only binary assets (images, fonts, media) are cached — CSS/JS are already excluded in `asset-downloader.ts:98` because they need URL rewriting. No changes to AssetDownloader or AssetCache.

---

## 4. Sitemap-Only Mode

**Finding**: `discoverLinks` already defaults to `false`, so sitemap-only IS the default. The scroll/hover triggers are for lazy-loaded **assets** (not page discovery), so they can't be eliminated.

**Optimization**: Add `sitemapOnly` option that reduces dynamic trigger overhead:
- Post-scroll wait: 500ms -> 200ms
- Scroll steps: `ceil(height / viewport)` -> `ceil(height / (viewport * 2))`
- Hover sample: 20 elements -> 10

**Wire in `crawler.ts`**: When `sitemapOnly` is true (default), also force `discoverLinks: false` and skip link extraction from HTML.

---

## Type Changes (`types.ts`)

```typescript
// CrawlOptions additions:
staticFastPath?: boolean;    // Default: true — try fetch before Playwright
sitemapOnly?: boolean;        // Default: true — reduced wait times, no link discovery
assetCacheDir?: string;       // Default: /tmp/dxd-asset-cache/{hostname}

// CrawlResult additions:
staticPages?: number;         // Count of pages processed without Playwright
cacheHitRate?: string;        // Asset cache hit rate

// PageResult additions:
static?: boolean;             // Whether static fast-path was used

// PageProcessorOptions additions:
tryStaticFirst?: boolean;     // Default: true
sitemapOnly?: boolean;         // Default: true
```

---

## Risk Assessment

| Optimization | Risk | Mitigation |
|---|---|---|
| Static fast-path false negative (page looks static but has dynamic content) | Medium | Conservative detection — any unrecognized indicator falls back to Playwright |
| Static fast-path misses assets | Low | `rewriteHtmlDocument` already handles all HTML-visible assets. Network-intercepted assets only exist for dynamic pages. |
| More pages per browser = memory pressure | Medium | Reduced per-page estimate (250->150MB). Static pages use 0 browser memory. Configurable via env var. |
| Stale cached assets | Very Low | Webflow CDN uses content-hashed URLs. Changed content = new URL = cache miss. |
| Reduced trigger timeouts miss lazy assets | Low | 200ms is still generous. Chunk manifest discovery (the main mechanism) is unaffected by timeout changes. |

---

## Verification

1. **Type check**: `npx turbo run build --filter=@dxd/scraper` (or `tsc --noEmit`)
2. **Unit test `detectDynamicContent`**:
   - Static HTML -> `isDynamic: false`
   - HTML with `<code-island>` -> detects it
   - HTML with `webpackChunk` in inline script -> detects it
   - HTML with `data-src` attributes -> detects it
3. **Integration test**: Crawl a known static Webflow site, verify:
   - Logs show "static, using fast path" for pages
   - Logs show "Asset cache: X hits, Y misses"
   - Output files are complete and correct
4. **Regression**: Compare output of static-path crawl vs full-Playwright crawl for same site — should be identical for truly static pages
5. **Concurrency**: Run with default settings (6 pages/browser), verify no OOM or browser crashes

## Expected Impact

| Optimization | Speed Improvement |
|---|---|
| Static fast-path | 30-60% for static-heavy sites (eliminates ~2-5s Playwright overhead per page) |
| Pages per browser (3->6) | ~40% fewer browser processes, modest throughput gain |
| Cross-crawl asset cache | 10-30% on repeat crawls (fonts, images skip re-download) |
| Sitemap-only timing | ~5% per page (reduced waits) |
| **Combined (initial crawl)** | **~40-50% faster** |
| **Combined (repeat crawl)** | **~50-70% faster** |
